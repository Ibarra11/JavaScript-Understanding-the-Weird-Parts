Objects & the dot

    Objects are collections of name/value pairs.  The values
    can also be an object aswell.

    Object can contain primitive properties, object property, and a 
    function.  A function inside a object is refered to as a method.

    THe object has references to the addresses of the propeties and 
    methodson it.

    Two ways of acessing propeties on an object
        Dot notation
            obj.property
        bracket notation
            obj['property']
    
    The dot operator or membor access and the Computed Memeber Acess or bracket notation are
    functions.  They have high precedence.  They take the object look for the property.


Objects and Object Literals

    Object Literal: a way of creating an object, but with just curly braces
    With object literals we can set the function up on line without having to manually
    for every propety.
    Whenever the JavaScript engine sees the curly braces it figues that you are trying
    to create an object.
    In other words, an object literal is just a shorthand way of creating an object.
        var person = {
            firstname: 'ALan Ibarra',
             lastname: 'Ibarra' 
        };

        var person = new Object();
        person.firstname = 'Alan Ibarra';
        person['lastname'] =  'Ibarra';

    
    You can also create a new object with the constructor function
        var person = new Object();


Faking Namespaces

    Namespace: a contaienr for variables and function

    We use namespaces to keep variables and function with the same name seperate

    JavaScript doesnt have namespaces

    But in JavaScript, we can fake namespaces with objects.

    The object gives us the ability to create a fake namespace.

    Namespace collision when two things are named the same.

JSON & Object Literals

    JSON or JavaScript Object Notation looks very similar to object, however, there are
    differences.  Any valid JSON is also valid object literal, but not the other way around
        1. Properties must be wrapped around quotes
        2. No traling commas
    
    We can convert an object to JSON with JSON.stringify(), which converts an object to JSON

    We can conver a JSON object ot object literal with JSON.parse(), it coverts it to a 
    JavaScript object.


Functions are Objects

    First Class Functions: everyting you do with other types you do with functions.

    All functions are objects.

    we can pass them into functions, return functions, and make functions on the fly,
    and assign variables to them.


    A function is a special type of object because all the features of a regual object,
    but also has some extra features.

    Since a function is an object, you can attach properties and methods.  You can even 
    attach other functions.

    It has two additonal properties 
        - A name property, which is optional.  iF no name is provided it is a anonymous function
        - code property, which contains the actual code we write in the funciton

    So any code we write inside the function gets added as a special propety on the function
    called code.

    The code property is special because you an alos invoke or run the function

    When you invoke the function thats when the whole execution context happens.

    If you want to acces a property on a funtion then you have to use
    the dot notation or bracket notation.  If you console.log the function
    you will not see the object properites, by default it will display the 
    code property, which is the code inside the funciotn.


Function Statements and Function Expressions

    Expression is a unit of code that results in a value 

    IF it returns a value, it is an expression.

    IF it doesnt return a value, then it is a statement.
        In this case if is a statement, it doesnt return anything
        the parenthes of the if statement is an expression because
        it evaluates and returns a result.
        if(i === 3)

    Function Statements
        This is a function statement becasue when it is evaluated, it 
        doesn't return a result
        function greet(){
            console.log('hi');
        }

    Function Expression
        var anaonymousGreet = function(){
            console.log('hi');
        }

        Hoisting does not work with function expressions, it does work
        with function statements.  The reaosn being is that the during
        the creation phase of the execution contexts the variable is 
        undefined and when you invoke it you are going to get an error.

        During the creation phase all variables are set to undefined.
        That is the reason why function expressions can not be undefined.

    
By Value vs By reference
    
    Primitive values   
        When you assign a variable to a primitve value.  The variable
        contains the memory address of where the variable is located 
        in memory.  With primitives if you assign a variable to
        another variable that contains a primiitve value it makes a copy

            In this example they are copies of each other, but sit in 
            different places in memory.  Changing one doesn't affect the
            other.
            var a = 5;
            var b = a;

    By value: two seperate copies in memory

    Primitive types are by value


    Objects

        With objects if you assign a variable equal to an objects property
        you are linking the variable to the same location that property points;
        Essentailly they both have the same memory reference.
        var obj = {a:1}
        var b = obj.a;
        b = 5;

        All objects are set by reference when setting them equal to variables
        or passing them to functions.  That includes function because
        functions are objects.

        var c = {greeting: 'hi'};
        THe javasvript engine sees this expression and sees that c
        is an object, it then assigns d the same memory reference that
        c contains to d.  In other words, both c and d reference the same
        place in  memory.  Changin one affects the other.
        var d = c;

        Mutate: TO change something

        immutable: means that it cant be changed

        Even when you pass obj as an argumement to a function
        , it can be mutated. because you are passing by reference.

        The equal operator sets up new memory space (new address)

        c = {greeting: ''}
        In this the equals operator sees that the object literal is 
        not a preexisitng object in memory, so it assigned a new 
        memory address for it.

        In sum, with obejcts if you are assigning a variable equal 
        to an object in memory that already exist, it is going to set
        the variable equal to same location memory as the object.  However,
        if you set a variable equal to an object does not exist, it creates
        a new memory space for that obejct and points the variable to it.


Objects, Functions, and this

    When a function is invoked, it creates a new exeuciton contexts

    Each execution context has a variable environemnt where all the 
    variables live.  It also has a link to the outer environment.  It;s
    outer environment is determined lexically where it sets.

    Each exectuion context creates the this keyword.

    At global exection this points the global object, which is hte 
    window.

    When you invoke the function or call the code property on the function,
    the this keyword inside function still points to the global object.

    So inside the function we can attach variables to the global object
    by doing something like this.newvariable = 'hello';  We then access
    that variable in the global execution context liek so newvariable

    So with object methods if you use the this keyword.  The this keyword
    actually points to the object itself not the global object.  With
    methods you can chagne the object properties within a method

    var c = {
        name: 'The c OBject',
        log: function(){
            this.name = 'YOu have been changed';
            console.log(this)
        }
    }

    Withing a method if you write another function.  The this keyword
    no longer points to the object, it points to the global object;
         var c = {
        name: 'The c OBject',
        log: function(){
            this.name = 'YOu have been changed';
            console.log(this)
            var ex = function(){
                console.log(this)
            }
        }
    }


Arrays Collections of Anythings

    An array is a collection.  The items in the array can be 
    of any type.

    In most programming languages an array can hold a list of 
    a certain type.

    An array can contain many types and is not restricted to one 
    type.

    Two ways to create an array

    var a = new Array();

    var a [];












